name: Deploy to Kubernetes Development

on:
  pull_request:
    branches: [ main, master ]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER: energy-company-dev
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  # Run CI first
  run-ci:
    name: Build and Test
    uses: ./.github/workflows/ci.yml

  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    needs: run-ci
    if: success()
    outputs:
      changed-services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Detect changed services
      id: changes
      run: |
        # Get the base branch commit
        BASE_SHA=$(git merge-base HEAD origin/${{ github.base_ref }})
        
        # Get list of changed files
        CHANGED_FILES=$(git diff --name-only $BASE_SHA...HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Initialize services array
        SERVICES=()
        
        # Check each service for changes
        if echo "$CHANGED_FILES" | grep -q "^api-gateway/"; then
          SERVICES+=("api-gateway")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^authentication-service/"; then
          SERVICES+=("authentication-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service/"; then
          SERVICES+=("consumption-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service-db-migration/"; then
          SERVICES+=("consumption-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service/"; then
          SERVICES+=("customer-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service-db-migration/"; then
          SERVICES+=("customer-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^elering-adapter/"; then
          SERVICES+=("elering-adapter")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^eureka-server/"; then
          SERVICES+=("eureka-server")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^energy-company-client/"; then
          SERVICES+=("energy-company-client")
        fi
        
        # Check for infrastructure or global changes
        if echo "$CHANGED_FILES" | grep -q "^k8s/\|^\.github/workflows/\|^build\.gradle$\|^settings\.gradle$"; then
          echo "Infrastructure or global changes detected - deploying all services"
          SERVICES=("api-gateway" "authentication-service" "consumption-service" "consumption-service-db-migration" "customer-service" "customer-service-db-migration" "elering-adapter" "eureka-server" "energy-company-client")
        fi
        
        # Convert array to JSON format compatible with GitHub Actions matrix
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "services=[]" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "No services have changed"
        else
          # Create properly formatted JSON array
          SERVICES_JSON="["
          for i in "${!SERVICES[@]}"; do
            if [ $i -gt 0 ]; then
              SERVICES_JSON+=","
            fi
            SERVICES_JSON+="\"${SERVICES[$i]}\""
          done
          SERVICES_JSON+="]"
          
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "Services to deploy: ${SERVICES[*]}"
          echo "Generated JSON: $SERVICES_JSON"
        fi

  # Deploy base infrastructure first
  deploy-infrastructure:
    name: Deploy Base Infrastructure
    runs-on: ubuntu-latest
    needs: [ detect-changes ]
    if: needs.detect-changes.outputs.has-changes == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name $EKS_CLUSTER --region $AWS_REGION

    - name: Deploy base infrastructure
      run: |
        echo "Applying base infrastructure..."
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/privileges.yaml
        kubectl apply -f k8s/ingress.yaml
        
        echo "✅ Base infrastructure deployed"

    - name: Create Kubernetes Secrets from GitHub Secrets
      run: |
        # Create database secrets using GitHub Secrets
        kubectl create secret generic consumption-db-secret \
          --from-literal=url="${{ secrets.CONSUMPTION_DB_URL }}" \
          --from-literal=username="${{ secrets.CONSUMPTION_DB_USERNAME }}" \
          --from-literal=password="${{ secrets.CONSUMPTION_DB_PASSWORD }}" \
          -n energy-company-dev \
          --dry-run=client -o yaml | kubectl apply -f -
        
        kubectl create secret generic customer-db-secret \
          --from-literal=url="${{ secrets.CUSTOMER_DB_URL }}" \
          --from-literal=username="${{ secrets.CUSTOMER_DB_USERNAME }}" \
          --from-literal=password="${{ secrets.CUSTOMER_DB_PASSWORD }}" \
          -n energy-company-dev \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "✅ Database secrets created from GitHub Secrets"

  build-and-deploy:
    name: Build and Deploy Services
    runs-on: ubuntu-latest
    needs: [ detect-changes, deploy-infrastructure ]
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed-services) }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name $EKS_CLUSTER --region $AWS_REGION

    - name: Determine service path
      id: service-path
      run: |
        case "${{ matrix.service }}" in
          "consumption-service")
            echo "path=consumption/consumption-service" >> $GITHUB_OUTPUT
            ;;
          "consumption-service-db-migration")
            echo "path=consumption/consumption-service-db-migration" >> $GITHUB_OUTPUT
            ;;
          "customer-service")
            echo "path=customer/customer-service" >> $GITHUB_OUTPUT
            ;;
          "customer-service-db-migration")
            echo "path=customer/customer-service-db-migration" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "path=${{ matrix.service }}" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Set up JDK 21 for Java services
      if: matrix.service != 'energy-company-client'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js for React client
      if: matrix.service == 'energy-company-client'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Build Java service
      if: matrix.service != 'energy-company-client'
      run: |
        cd ${{ steps.service-path.outputs.path }}
        chmod +x ./gradlew
        ./gradlew build -x test

    - name: Build React client
      if: matrix.service == 'energy-company-client'
      run: |
        cd ${{ steps.service-path.outputs.path }}
        npm ci
        npm run build

    - name: Login to Amazon ECR
      run: aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

    - name: Build and push Docker image
      run: |
        ECR_REPOSITORY="energy-company-${{ matrix.service }}-dev"
        IMAGE_TAG="${{ github.sha }}"
        
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION 2>/dev/null || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Build and push Docker image using the correct service path
        echo "Building Docker image from path: ${{ steps.service-path.outputs.path }}"
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Deploy to Kubernetes
      run: |
        SERVICE_K8S_PATH="${{ steps.service-path.outputs.path }}/k8s"
        IMAGE_URL="$ECR_REGISTRY/energy-company-${{ matrix.service }}-dev:${{ github.sha }}"
        
        echo "Deploying service: ${{ matrix.service }}"
        echo "K8s path: $SERVICE_K8S_PATH"
        
        # Check if k8s directory exists
        if [ ! -d "$SERVICE_K8S_PATH" ]; then
          echo "Error: K8s directory not found at $SERVICE_K8S_PATH"
          exit 1
        fi
        
        # Apply manifests in order: secrets, configmaps, deployments, services, jobs
        
        # 1. Apply secrets first (if exists)
        if [ -f "$SERVICE_K8S_PATH/secret.yaml" ]; then
          echo "Applying secrets..."
          kubectl apply -f "$SERVICE_K8S_PATH/secret.yaml"
        fi
        
        # 2. Apply configmaps (if exists)
        if [ -f "$SERVICE_K8S_PATH/configmap.yaml" ]; then
          echo "Applying configmaps..."
          kubectl apply -f "$SERVICE_K8S_PATH/configmap.yaml"
        fi
        
        # 3. Apply deployments (if exists)
        if [ -f "$SERVICE_K8S_PATH/deployment.yaml" ]; then
          echo "Applying deployment..."
          kubectl apply -f "$SERVICE_K8S_PATH/deployment.yaml"
          
          echo "Updating Deployment image..."
          kubectl set image deployment/${{ matrix.service }} \
            ${{ matrix.service }}=$IMAGE_URL \
            -n energy-company-dev
          
          echo "Waiting for rollout to complete..."
          kubectl rollout status deployment/${{ matrix.service }} -n energy-company-dev --timeout=5m
        fi
        
        # 4. Apply services (if exists)
        if [ -f "$SERVICE_K8S_PATH/service.yaml" ]; then
          echo "Applying service..."
          kubectl apply -f "$SERVICE_K8S_PATH/service.yaml"
        fi
        
        # 5. Apply jobs for migration services (if exists)
        if [ -f "$SERVICE_K8S_PATH/job.yaml" ]; then
          echo "Applying job..."
          
          # Delete existing job if it exists
          kubectl delete job ${{ matrix.service }} -n energy-company-dev --ignore-not-found=true
          
          # Update image in job and apply
          sed "s#image: .*#image: $IMAGE_URL#g" "$SERVICE_K8S_PATH/job.yaml" | kubectl apply -f -
          
          echo "Waiting for Job to complete..."
          kubectl wait --for=condition=complete job/${{ matrix.service }} -n energy-company-dev --timeout=10m
        fi

    - name: Verify deployment
      run: |
        echo "Checking deployment status for ${{ matrix.service }}..."
        kubectl get pods -n energy-company-dev -l app=${{ matrix.service }}
        
        if kubectl get deployment ${{ matrix.service }} -n energy-company-dev >/dev/null 2>&1; then
          kubectl describe deployment ${{ matrix.service }} -n energy-company-dev
        elif kubectl get job ${{ matrix.service }} -n energy-company-dev >/dev/null 2>&1; then
          kubectl describe job ${{ matrix.service }} -n energy-company-dev
        fi
