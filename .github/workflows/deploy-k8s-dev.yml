name: Deploy to Kubernetes Development

on:
  pull_request:
    branches: [ main, master ]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  EKS_CLUSTER: energy-company-dev
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  # Run CI first
  run-ci:
    name: Build and Test
    uses: ./.github/workflows/ci.yml

  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    needs: run-ci
    if: success()
    outputs:
      changed-services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Detect changed services
        id: changes
        run: |
          BASE_SHA=$(git merge-base HEAD origin/${{ github.base_ref }})
          CHANGED_FILES=$(git diff --name-only $BASE_SHA...HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          SERVICES=()
          
          # Check each service for changes
          if echo "$CHANGED_FILES" | grep -q "^api-gateway/"; then SERVICES+=("api-gateway"); fi
          if echo "$CHANGED_FILES" | grep -q "^authentication-service/"; then SERVICES+=("authentication-service"); fi
          if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service/"; then SERVICES+=("consumption-service"); fi
          if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service-db-migration/"; then SERVICES+=("consumption-service-db-migration"); fi
          if echo "$CHANGED_FILES" | grep -q "^customer/customer-service/"; then SERVICES+=("customer-service"); fi
          if echo "$CHANGED_FILES" | grep -q "^customer/customer-service-db-migration/"; then SERVICES+=("customer-service-db-migration"); fi
          if echo "$CHANGED_FILES" | grep -q "^elering-adapter/"; then SERVICES+=("elering-adapter"); fi
          if echo "$CHANGED_FILES" | grep -q "^eureka-server/"; then SERVICES+=("eureka-server"); fi
          if echo "$CHANGED_FILES" | grep -q "^energy-company-client/"; then SERVICES+=("energy-company-client"); fi
          
          # Check for infrastructure or global changes
          if echo "$CHANGED_FILES" | grep -q "^k8s/\|^\.github/workflows/\|^build\.gradle$\|^settings\.gradle$"; then
            echo "Infrastructure or global changes detected - deploying all services"
            SERVICES=("api-gateway" "authentication-service" "consumption-service" "consumption-service-db-migration" "customer-service" "customer-service-db-migration" "elering-adapter" "eureka-server" "energy-company-client")
          fi
          
          if [ ${#SERVICES[@]} -eq 0 ]; then
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
          else
            SERVICES_JSON=$(printf '%s\n' "${SERVICES[@]}" | jq -R . | jq -s .)
            echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
          fi


  # Setup Kubernetes Namespace and Secrets
  setup-kubernetes:
    name: Setup Kubernetes Namespace and Secrets
    runs-on: ubuntu-latest
    needs: [ detect-changes ]
    if: needs.detect-changes.outputs.has-changes == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name $EKS_CLUSTER --region $AWS_REGION

      - name: Apply Kubernetes Namespace
        # Assuming your namespace file is at this path
        run: kubectl apply -f k8s/namespace.yaml

      - name: Create Kubernetes Secrets from GitHub Secrets
        run: |
          kubectl create secret generic consumption-db-secret \
            --from-literal=url="${{ secrets.CONSUMPTION_DB_URL }}" \
            --from-literal=username="${{ secrets.CONSUMPTION_DB_USERNAME }}" \
            --from-literal=password="${{ secrets.CONSUMPTION_DB_PASSWORD }}" \
            -n energy-company-dev \
            --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic customer-db-secret \
            --from-literal=url="${{ secrets.CUSTOMER_DB_URL }}" \
            --from-literal=username="${{ secrets.CUSTOMER_DB_USERNAME }}" \
            --from-literal=password="${{ secrets.CUSTOMER_DB_PASSWORD }}" \
            -n energy-company-dev \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ Namespace and Database secrets configured."


  # Build and Deploy Changed Services
  build-and-deploy:
    name: Build and Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [ setup-kubernetes, detect-changes ]
    if: success() # Only run if the setup job succeeds
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed-services) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name $EKS_CLUSTER --region $AWS_REGION

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Determine service path
        id: service-path
        run: |
          SERVICE_PATH=""
          case "${{ matrix.service }}" in
            "consumption-service") SERVICE_PATH="consumption/consumption-service" ;;
            "consumption-service-db-migration") SERVICE_PATH="consumption/consumption-service-db-migration" ;;
            "customer-service") SERVICE_PATH="customer/customer-service" ;;
            "customer-service-db-migration") SERVICE_PATH="customer/customer-service-db-migration" ;;
            *) SERVICE_PATH="${{ matrix.service }}" ;;
          esac
          echo "path=$SERVICE_PATH" >> $GITHUB_OUTPUT

      - name: Build backend service
        if: matrix.service != 'energy-company-client'
        run: |
          chmod +x ./gradlew
          PROJECT_PATH=":${{ matrix.service }}"
          echo "Building specific project: $PROJECT_PATH"
          ./gradlew "$PROJECT_PATH:build" -x test

      - name: Build frontend
        if: matrix.service == 'energy-company-client'
        working-directory: ./energy-company-client
        run: |
          npm ci
          npm run build

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REPOSITORY: energy-company-${{ matrix.service }}-dev
          IMAGE_TAG: ${{ github.sha }}
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION 2>/dev/null || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
          
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      - name: Deploy to Kubernetes
        run: |
          MANIFEST_PATH="k8s/${{ matrix.service }}.yaml"
          
          if [ ! -f "$MANIFEST_PATH" ]; then
            echo "Manifest file not found at $MANIFEST_PATH"
            exit 1
          fi
          
          echo "Applying manifest: $MANIFEST_PATH"
          kubectl apply -f "$MANIFEST_PATH"
          
          # This assumes your manifest contains either a Deployment or a Job.
          # It updates the image for the specific resource.
          RESOURCE_KIND=$(kubectl get -f "$MANIFEST_PATH" -o jsonpath='{.kind}')
          
          if [[ "$RESOURCE_KIND" == "Deployment" ]]; then
            echo "Updating Deployment image..."
            kubectl set image deployment/${{ matrix.service }} \
              ${{ matrix.service }}=$ECR_REGISTRY/energy-company-${{ matrix.service }}-dev:${{ github.sha }} \
              -n energy-company-dev
          
            echo "Waiting for rollout to complete..."
            kubectl rollout status deployment/${{ matrix.service }} -n energy-company-dev --timeout=5m
          
          elif [[ "$RESOURCE_KIND" == "Job" ]]; then
            echo "Resource is a Job. No image update or rollout status check needed after creation."
            # If you need to re-run the job, you might delete the old one first:
            # kubectl delete job ${{ matrix.service }} -n energy-company-dev --ignore-not-found=true
            # kubectl apply -f "$MANIFEST_PATH"
          else
            echo "Unsupported resource kind '$RESOURCE_KIND' for automatic image update."
          fi
          
          echo "✅ ${{ matrix.service }} deployed successfully to Kubernetes!"


  # Notify Deployment Status
  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [ setup-kubernetes, build-and-deploy ]
    if: always()
    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { repo, owner, number } = context.issue;
            const needs_result = '${{ needs.build-and-deploy.result }}';
            let message;
            
            if (needs_result === 'success') {
              message = '🚀 **Deployment Successful**\n\nAll changed services were deployed to the development environment.';
            } else if (needs_result === 'failure') {
              message = '❌ **Deployment Failed**\n\nPlease check the workflow logs for errors.';
            } else if (needs_result === 'skipped') {
              message = '⚪ **Deployment Skipped**\n\nNo changes detected in deployable services.';
            } else {
              message = '🟡 **Deployment Status Unknown**\n\nThe deployment job finished with a status of: ' + needs_result;
            }
            
            github.rest.issues.createComment({
              owner: owner,
              repo: repo,
              issue_number: number,
              body: message
            });