name: Deploy to Development

on:
  pull_request:
    branches: [ main, master ]
    types: [opened, synchronize, reopened]

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER: energy-company-dev
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  build-and-deploy:
    name: Build and Deploy to Development
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    strategy:
      matrix:
        service:
          - name: api-gateway
            port: 4000
          - name: authentication-service
            port: 2000
          - name: consumption-service
            path: consumption/consumption-service
            port: 5006
          - name: consumption-service-db-migration
            path: consumption/consumption-service-db-migration
            port: 7006
          - name: customer-service
            path: customer/customer-service
            port: 5007
          - name: customer-service-db-migration
            path: customer/customer-service-db-migration
            port: 7005
          - name: elering-adapter
            port: 5005
          - name: eureka-server
            port: 8761
          - name: energy-company-client
            port: 5173

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set service path
      id: service-path
      run: |
        if [ "${{ matrix.service.path }}" != "" ]; then
          echo "path=${{ matrix.service.path }}" >> $GITHUB_OUTPUT
        else
          echo "path=${{ matrix.service.name }}" >> $GITHUB_OUTPUT
        fi

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      if: matrix.service.name != 'energy-company-client'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js ${{ env.NODE_VERSION }}
      if: matrix.service.name == 'energy-company-client'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: energy-company-client/package-lock.json

    - name: Cache Gradle packages
      if: matrix.service.name != 'energy-company-client'
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Build backend service
      if: matrix.service.name != 'energy-company-client'
      run: |
        chmod +x ./gradlew
        ./gradlew clean build -x test --no-daemon

    - name: Build frontend
      if: matrix.service.name == 'energy-company-client'
      working-directory: ./energy-company-client
      run: |
        npm ci
        npm run build

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REPOSITORY: energy-company-${{ matrix.service.name }}-dev
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Build and push Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Update ECS service
      env:
        ECR_REPOSITORY: energy-company-${{ matrix.service.name }}-dev
        IMAGE_TAG: ${{ github.sha }}
        ECS_SERVICE: ${{ matrix.service.name }}-dev
        ECS_TASK_DEFINITION: ${{ matrix.service.name }}-dev
      run: |
        # Download current task definition
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION \
          --query taskDefinition > task-definition.json
        
        # Update the image in task definition
        python3 - << EOF
        import json
        import sys
        
        with open('task-definition.json', 'r') as f:
            task_def = json.load(f)
        
        # Remove fields that shouldn't be in the updated task definition
        for key in ['taskDefinitionArn', 'revision', 'status', 'requiresAttributes', 'placementConstraints', 'compatibilities', 'registeredAt', 'registeredBy']:
            task_def.pop(key, None)
        
        # Update the image
        for container in task_def['containerDefinitions']:
            if container['name'] == '${{ matrix.service.name }}':
                container['image'] = '$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG'
        
        with open('task-definition-updated.json', 'w') as f:
            json.dump(task_def, f, indent=2)
        EOF
        
        # Register new task definition
        aws ecs register-task-definition --cli-input-json file://task-definition-updated.json
        
        # Update the service
        aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE \
          --task-definition $ECS_TASK_DEFINITION || echo "Service $ECS_SERVICE not found, skipping update"

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()

    steps:
    - name: Comment on PR
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => comment.user.login === 'github-actions[bot]' && comment.body.includes('🚀 Development Deployment'));
          
          const deploymentStatus = '${{ needs.build-and-deploy.result }}' === 'success' ? '✅ Successful' : '❌ Failed';
          
          const body = `## 🚀 Development Deployment Status
          
          **Status**: ${deploymentStatus}
          **Commit**: \`${{ github.sha }}\`
          **Environment**: Development
          
          ${deploymentStatus === '✅ Successful' ? 
            '🎉 Your changes have been successfully deployed to the development environment!' :
            '⚠️ Deployment failed. Please check the workflow logs for details.'}
          
          ---
          *This comment will be updated on subsequent deployments*`;
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }