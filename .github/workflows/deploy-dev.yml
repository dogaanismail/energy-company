name: Deploy to Development

on:
  pull_request:
    branches: [ main, master ]
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER: energy-company-dev
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  # Run CI first - deployment depends on this
  run-ci:
    name: Build and Test (Required)
    uses: ./.github/workflows/ci.yml

  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    needs: run-ci
    if: success()
    outputs:
      changed-services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changed services
      id: changes
      run: |
        # Get the base branch commit
        BASE_SHA=$(git merge-base HEAD origin/${{ github.base_ref }})
        
        # Get list of changed files
        CHANGED_FILES=$(git diff --name-only $BASE_SHA...HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Initialize services array
        SERVICES=()
        
        # Check each service for changes
        if echo "$CHANGED_FILES" | grep -q "^api-gateway/"; then
          SERVICES+=("api-gateway")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^authentication-service/"; then
          SERVICES+=("authentication-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service/"; then
          SERVICES+=("consumption-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service-db-migration/"; then
          SERVICES+=("consumption-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service/"; then
          SERVICES+=("customer-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service-db-migration/"; then
          SERVICES+=("customer-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^elering-adapter/"; then
          SERVICES+=("elering-adapter")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^eureka-server/"; then
          SERVICES+=("eureka-server")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^energy-company-client/"; then
          SERVICES+=("energy-company-client")
        fi
        
        # Check for infrastructure changes
        if echo "$CHANGED_FILES" | grep -q "^\.aws/\|^\.github/workflows/\|^docker-compose\|^build\.gradle$\|^settings\.gradle$"; then
          echo "Infrastructure or global changes detected - deploying all services"
          SERVICES=("api-gateway" "authentication-service" "consumption-service" "consumption-service-db-migration" "customer-service" "customer-service-db-migration" "elering-adapter" "eureka-server" "energy-company-client")
        fi
        
        # Convert array to JSON format compatible with GitHub Actions matrix
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "services=[]" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "No services have changed"
        else
          # Create properly formatted JSON array
          SERVICES_JSON="["
          for i in "${!SERVICES[@]}"; do
            if [ $i -gt 0 ]; then
              SERVICES_JSON+=","
            fi
            SERVICES_JSON+="\"${SERVICES[$i]}\""
          done
          SERVICES_JSON+="]"
          
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "Services to deploy: ${SERVICES[*]}"
          echo "Generated JSON: $SERVICES_JSON"
        fi

  # Setup basic infrastructure using default VPC
  setup-infrastructure:
    name: Setup Basic Infrastructure
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    outputs:
      vpc-id: ${{ steps.vpc.outputs.vpc-id }}
      subnets: ${{ steps.vpc.outputs.subnets }}
      security-group: ${{ steps.vpc.outputs.security-group }}

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup basic infrastructure using default VPC
      id: vpc
      run: |
        echo "ðŸ—ï¸ Setting up basic infrastructure using default VPC..."
        
        # Get or create default VPC
        DEFAULT_VPC=$(aws ec2 describe-vpcs \
          --filters "Name=is-default,Values=true" \
          --query "Vpcs[0].VpcId" \
          --output text \
          --region $AWS_REGION)
        
        if [ "$DEFAULT_VPC" = "None" ] || [ -z "$DEFAULT_VPC" ]; then
          echo "Creating default VPC..."
          aws ec2 create-default-vpc --region $AWS_REGION
          DEFAULT_VPC=$(aws ec2 describe-vpcs \
            --filters "Name=is-default,Values=true" \
            --query "Vpcs[0].VpcId" \
            --output text \
            --region $AWS_REGION)
        fi
        
        echo "âœ… Using VPC: $DEFAULT_VPC"
        
        # Get subnets in default VPC
        SUBNETS=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=$DEFAULT_VPC" \
          --query "Subnets[*].SubnetId" \
          --output text \
          --region $AWS_REGION)
        
        # Convert to comma-separated list
        SUBNETS_CSV=$(echo $SUBNETS | tr ' ' ',')
        
        echo "âœ… Found subnets: $SUBNETS_CSV"
        
        # Get default security group
        DEFAULT_SG=$(aws ec2 describe-security-groups \
          --filters "Name=vpc-id,Values=$DEFAULT_VPC" "Name=group-name,Values=default" \
          --query "SecurityGroups[0].GroupId" \
          --output text \
          --region $AWS_REGION)
        
        echo "âœ… Using security group: $DEFAULT_SG"
        
        # Open required ports in security group
        echo "ðŸ”“ Opening required ports..."
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 4000 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 4000 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 5006 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 5006 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 5173 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 5173 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 7005 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 7005 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 7006 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 7006 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 8080 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 8080 rule already exists"
        
        aws ec2 authorize-security-group-ingress \
          --group-id $DEFAULT_SG \
          --protocol tcp \
          --port 8761 \
          --cidr 0.0.0.0/0 \
          --region $AWS_REGION 2>/dev/null || echo "Port 8761 rule already exists"
        
        # Create ECS cluster if it doesn't exist
        echo "ðŸš€ Setting up ECS cluster..."
        aws ecs create-cluster --cluster-name $ECS_CLUSTER --region $AWS_REGION 2>/dev/null || echo "Cluster already exists"
        
        # Create basic IAM role for ECS tasks
        echo "ðŸ” Setting up IAM roles..."
        aws iam create-role --role-name ecsTaskExecutionRole \
          --assume-role-policy-document '{
            "Version": "2012-10-17",
            "Statement": [{
              "Effect": "Allow",
              "Principal": {"Service": "ecs-tasks.amazonaws.com"},
              "Action": "sts:AssumeRole"
            }]
          }' 2>/dev/null || echo "ecsTaskExecutionRole already exists"
        
        aws iam attach-role-policy \
          --role-name ecsTaskExecutionRole \
          --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy 2>/dev/null || true
        
        # Set outputs
        echo "vpc-id=$DEFAULT_VPC" >> $GITHUB_OUTPUT
        echo "subnets=$SUBNETS_CSV" >> $GITHUB_OUTPUT
        echo "security-group=$DEFAULT_SG" >> $GITHUB_OUTPUT
        
        echo "âœ… Infrastructure setup complete!"


  build-and-deploy:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [detect-changes, setup-infrastructure]
    if: needs.detect-changes.outputs.has-changes == 'true'

    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed-services) }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set service path
      id: service-path
      run: |
        case "${{ matrix.service }}" in
          "api-gateway")
            echo "path=api-gateway" >> $GITHUB_OUTPUT
            ;;
          "authentication-service")
            echo "path=authentication-service" >> $GITHUB_OUTPUT
            ;;
          "consumption-service")
            echo "path=consumption/consumption-service" >> $GITHUB_OUTPUT
            ;;
          "consumption-service-db-migration")
            echo "path=consumption/consumption-service-db-migration" >> $GITHUB_OUTPUT
            ;;
          "customer-service")
            echo "path=customer/customer-service" >> $GITHUB_OUTPUT
            ;;
          "customer-service-db-migration")
            echo "path=customer/customer-service-db-migration" >> $GITHUB_OUTPUT
            ;;
          "elering-adapter")
            echo "path=elering-adapter" >> $GITHUB_OUTPUT
            ;;
          "eureka-server")
            echo "path=eureka-server" >> $GITHUB_OUTPUT
            ;;
          "energy-company-client")
            echo "path=energy-company-client" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "path=${{ matrix.service }}" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      if: matrix.service != 'energy-company-client'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js ${{ env.NODE_VERSION }}
      if: matrix.service == 'energy-company-client'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: energy-company-client/package-lock.json

    - name: Cache Gradle packages
      if: matrix.service != 'energy-company-client'
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Build backend service
      if: matrix.service != 'energy-company-client'
      run: |
        chmod +x ./gradlew
        ./gradlew clean build -x test --no-daemon

    - name: Build frontend
      if: matrix.service == 'energy-company-client'
      working-directory: ./energy-company-client
      run: |
        npm ci
        npm run build

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REPOSITORY: energy-company-${{ matrix.service }}-dev
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Build and push Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

    - name: Update ECS task definition and service
      run: |
        TASK_DEFINITION_FAMILY="${{ matrix.service }}-dev"
        SERVICE_NAME="${{ matrix.service }}-dev"
        ECR_REPOSITORY="energy-company-${{ matrix.service }}-dev"
        IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:${{ github.sha }}"
        
        # Set the correct container port based on service
        case "${{ matrix.service }}" in
          "eureka-server")
            CONTAINER_PORT=8761
            ;;
          "api-gateway")
            CONTAINER_PORT=4000
            ;;
          "consumption-service")
            CONTAINER_PORT=5006
            ;;
          "consumption-service-db-migration")
            CONTAINER_PORT=7006
            ;;
          "customer-service")
            CONTAINER_PORT=8080
            ;;
          "customer-service-db-migration")
            CONTAINER_PORT=7005
            ;;
          "energy-company-client")
            CONTAINER_PORT=5173
            ;;
          *)
            CONTAINER_PORT=8080
            ;;
        esac
        
        # Create task definition JSON based on service type
        if [[ "${{ matrix.service }}" == "consumption-service" ]]; then
          # Consumption service with database environment variables
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [
                {"name": "DB_SERVICE_URL", "value": "${{ secrets.CONSUMPTION_DB_URL }}"},
                {"name": "DB_SERVICE_USERNAME", "value": "${{ secrets.CONSUMPTION_DB_USERNAME }}"},
                {"name": "DB_SERVICE_PASSWORD", "value": "${{ secrets.CONSUMPTION_DB_PASSWORD }}"},
                {"name": "EUREKA_SERVICE_URL", "value": "http://eureka-server-dev.energy-company-dev:8761/eureka/"}
              ],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        elif [[ "${{ matrix.service }}" == "consumption-service-db-migration" ]]; then
          # Consumption DB migration service
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [
                {"name": "DB_SERVICE_URL", "value": "${{ secrets.CONSUMPTION_DB_URL }}"},
                {"name": "DB_SERVICE_USERNAME", "value": "${{ secrets.CONSUMPTION_DB_USERNAME }}"},
                {"name": "DB_SERVICE_PASSWORD", "value": "${{ secrets.CONSUMPTION_DB_PASSWORD }}"}
              ],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        elif [[ "${{ matrix.service }}" == "customer-service" ]]; then
          # Customer service with database environment variables
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [
                {"name": "DB_SERVICE_URL", "value": "${{ secrets.CUSTOMER_DB_URL }}"},
                {"name": "DB_SERVICE_USERNAME", "value": "${{ secrets.CUSTOMER_DB_USERNAME }}"},
                {"name": "DB_SERVICE_PASSWORD", "value": "${{ secrets.CUSTOMER_DB_PASSWORD }}"},
                {"name": "EUREKA_SERVICE_URL", "value": "http://eureka-server-dev.energy-company-dev:8761/eureka/"}
              ],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        elif [[ "${{ matrix.service }}" == "customer-service-db-migration" ]]; then
          # Customer DB migration service
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [
                {"name": "DB_SERVICE_URL", "value": "${{ secrets.CUSTOMER_DB_URL }}"},
                {"name": "DB_SERVICE_USERNAME", "value": "${{ secrets.CUSTOMER_DB_USERNAME }}"},
                {"name": "DB_SERVICE_PASSWORD", "value": "${{ secrets.CUSTOMER_DB_PASSWORD }}"}
              ],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        elif [[ "${{ matrix.service }}" == "api-gateway" ]]; then
          # API Gateway with Eureka configuration
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [
                {"name": "EUREKA_SERVICE_URL", "value": "http://eureka-server-dev.energy-company-dev:8761/eureka/"}
              ],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        else
          # Default configuration for other services
          cat > "/tmp/${TASK_DEFINITION_FAMILY}.json" << 'EOF'
        {
          "family": "$TASK_DEFINITION_FAMILY",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "${{ matrix.service }}",
              "image": "$IMAGE_URI",
              "essential": true,
              "environment": [],
              "portMappings": [
                {
                  "containerPort": $CONTAINER_PORT,
                  "protocol": "tcp"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ matrix.service }}-dev",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        fi
        
        # Replace variables in the JSON file
        sed -i "s/\$TASK_DEFINITION_FAMILY/$TASK_DEFINITION_FAMILY/g" "/tmp/${TASK_DEFINITION_FAMILY}.json"
        sed -i "s/\$IMAGE_URI/$IMAGE_URI/g" "/tmp/${TASK_DEFINITION_FAMILY}.json"
        sed -i "s/\$CONTAINER_PORT/$CONTAINER_PORT/g" "/tmp/${TASK_DEFINITION_FAMILY}.json"
        sed -i "s/\$AWS_REGION/$AWS_REGION/g" "/tmp/${TASK_DEFINITION_FAMILY}.json"
        
        # Create log group
        aws logs create-log-group --log-group-name "/ecs/${{ matrix.service }}-dev" --region $AWS_REGION 2>/dev/null || echo "Log group already exists"
        
        # Register the new task definition
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "file:///tmp/${TASK_DEFINITION_FAMILY}.json" --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "âœ… Registered task definition: $NEW_TASK_DEF_ARN"
        
        # Check if service exists
        if aws ecs describe-services --cluster "$ECS_CLUSTER" --services "$SERVICE_NAME" --query 'services[?status==`ACTIVE`]' --output text --region $AWS_REGION | grep -q "$SERVICE_NAME"; then
          echo "Service $SERVICE_NAME exists - updating existing service"
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$SERVICE_NAME" \
            --task-definition "$TASK_DEFINITION_FAMILY" \
            --force-new-deployment \
            --region $AWS_REGION
        else
          echo "Service $SERVICE_NAME does not exist - creating new service"
          
          # Convert comma-separated subnets to JSON array
          SUBNETS_JSON=$(echo "${{ needs.setup-infrastructure.outputs.subnets }}" | sed 's/,/","/g' | sed 's/^/"/' | sed 's/$/"/')
          
          # Create the service with proper network configuration
          aws ecs create-service \
            --cluster "$ECS_CLUSTER" \
            --service-name "$SERVICE_NAME" \
            --task-definition "$TASK_DEFINITION_FAMILY" \
            --desired-count 1 \
            --launch-type "FARGATE" \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS_JSON],securityGroups=[\"${{ needs.setup-infrastructure.outputs.security-group }}\"],assignPublicIp=ENABLED}" \
            --region $AWS_REGION
        fi
        
        # Wait for the service to become stable
        echo "â³ Waiting for service $SERVICE_NAME to stabilize..."
        aws ecs wait services-stable --cluster "$ECS_CLUSTER" --services "$SERVICE_NAME" --region $AWS_REGION
        echo "âœ… Service $SERVICE_NAME is stable and running!"


  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-deploy]
    if: always()

    steps:
    - name: Comment on PR
      uses: actions/github-script@v7
      with:
        script: |
          const changedServices = ${{ needs.detect-changes.outputs.changed-services }};
          const hasChanges = '${{ needs.detect-changes.outputs.has-changes }}' === 'true';
          const deploymentStatus = '${{ needs.build-and-deploy.result }}';
          
          let body;
          
          if (!hasChanges) {
            body = `## ðŸ” No Services Changed
            
            **Status**: âšª No Deployment Needed
            **Commit**: \`${{ github.sha }}\`
            **Environment**: Development
            
            No microservices were modified in this PR, so no deployment is necessary.
            
            ---
            *Smart deployment: Only changed services are deployed*`;
          } else {
            const status = deploymentStatus === 'success' ? 'âœ… Successful' : 'âŒ Failed';
            const servicesList = changedServices.map(s => `â€¢ ${s}`).join('\n            ');
            
            body = `## ðŸš€ Development Deployment Status
            
            **Status**: ${status}
            **Commit**: \`${{ github.sha }}\`
            **Environment**: Development
            **Services Deployed**:
            ${servicesList}
            
            ${status === 'âœ… Successful' ? 
              'ðŸŽ‰ Changed services have been successfully deployed to the development environment!' :
              'âš ï¸ Deployment failed. Please check the workflow logs for details.'}
            
            ---
            *Smart deployment: Only changed services are deployed*`;
          }
          
          // Post or update comment logic (same as before)
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => comment.user.login === 'github-actions[bot]' && comment.body.includes('ðŸš€ Development Deployment'));
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }

