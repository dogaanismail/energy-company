name: Deploy to Production

on:
  push:
    branches: [ main, master ]

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER: energy-company-prod
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy databases
      run: |
        # Create RDS PostgreSQL instances if they don't exist
        echo "Checking for customer database..."
        if ! aws rds describe-db-instances --db-instance-identifier energy-company-customer-prod --region $AWS_REGION 2>/dev/null; then
          echo "Creating customer database..."
          # This would create the RDS instance - simplified for demo
          echo "Customer DB creation would happen here"
        fi
        
        echo "Checking for consumption database..."
        if ! aws rds describe-db-instances --db-instance-identifier energy-company-consumption-prod --region $AWS_REGION 2>/dev/null; then
          echo "Creating consumption database..."
          # This would create the RDS instance - simplified for demo
          echo "Consumption DB creation would happen here"
        fi

  build-and-deploy:
    name: Build and Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    strategy:
      matrix:
        service:
          - name: eureka-server
            port: 8761
            priority: 1
          - name: api-gateway
            port: 4000
            priority: 5
          - name: authentication-service
            port: 2000
            priority: 4
          - name: customer-service-db-migration
            path: customer/customer-service-db-migration
            port: 7005
            priority: 2
          - name: customer-service
            path: customer/customer-service
            port: 5007
            priority: 3
          - name: consumption-service-db-migration
            path: consumption/consumption-service-db-migration
            port: 7006
            priority: 2
          - name: consumption-service
            path: consumption/consumption-service
            port: 5006
            priority: 3
          - name: elering-adapter
            port: 5005
            priority: 3
          - name: energy-company-client
            port: 5173
            priority: 6

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set service path
      id: service-path
      run: |
        if [ "${{ matrix.service.path }}" != "" ]; then
          echo "path=${{ matrix.service.path }}" >> $GITHUB_OUTPUT
        else
          echo "path=${{ matrix.service.name }}" >> $GITHUB_OUTPUT
        fi

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      if: matrix.service.name != 'energy-company-client'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js ${{ env.NODE_VERSION }}
      if: matrix.service.name == 'energy-company-client'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: energy-company-client/package-lock.json

    - name: Cache Gradle packages
      if: matrix.service.name != 'energy-company-client'
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Build backend service
      if: matrix.service.name != 'energy-company-client'
      run: |
        chmod +x ./gradlew
        ./gradlew clean build -x test --no-daemon

    - name: Build frontend
      if: matrix.service.name == 'energy-company-client'
      working-directory: ./energy-company-client
      run: |
        npm ci
        npm run build

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REPOSITORY: energy-company-${{ matrix.service.name }}-prod
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Build and push Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy-services:
    name: Deploy Services by Priority
    runs-on: ubuntu-latest
    needs: build-and-deploy

    strategy:
      matrix:
        priority: [1, 2, 3, 4, 5, 6]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy services with priority ${{ matrix.priority }}
      env:
        IMAGE_TAG: ${{ github.sha }}
        PRIORITY: ${{ matrix.priority }}
      run: |
        # Define services by priority
        case $PRIORITY in
          1) SERVICES="eureka-server" ;;
          2) SERVICES="customer-service-db-migration consumption-service-db-migration" ;;
          3) SERVICES="customer-service consumption-service elering-adapter" ;;
          4) SERVICES="authentication-service" ;;
          5) SERVICES="api-gateway" ;;
          6) SERVICES="energy-company-client" ;;
        esac
        
        for service in $SERVICES; do
          echo "Deploying $service..."
          
          ECR_REPOSITORY="energy-company-$service-prod"
          ECS_SERVICE="$service-prod"
          ECS_TASK_DEFINITION="$service-prod"
          
          # Check if service exists
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION 2>/dev/null | grep -q "ACTIVE"; then
            echo "Updating existing service: $service"
            
            # Download current task definition
            aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION \
              --query taskDefinition > task-definition.json
            
            # Update the image in task definition
            python3 - << EOF
        import json
        
        with open('task-definition.json', 'r') as f:
            task_def = json.load(f)
        
        # Remove fields that shouldn't be in the updated task definition
        for key in ['taskDefinitionArn', 'revision', 'status', 'requiresAttributes', 'placementConstraints', 'compatibilities', 'registeredAt', 'registeredBy']:
            task_def.pop(key, None)
        
        # Update the image
        for container in task_def['containerDefinitions']:
            if container['name'] == '$service':
                container['image'] = '$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG'
        
        with open('task-definition-updated.json', 'w') as f:
            json.dump(task_def, f, indent=2)
        EOF
            
            # Register new task definition
            aws ecs register-task-definition --cli-input-json file://task-definition-updated.json
            
            # Update the service
            aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE \
              --task-definition $ECS_TASK_DEFINITION
              
            # Wait for deployment to complete
            aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE
            
          else
            echo "Service $service does not exist yet - would need to be created with proper task definition"
          fi
        done
        
        # Wait between priority levels
        if [ "$PRIORITY" -lt 6 ]; then
          echo "Waiting 30 seconds before next priority level..."
          sleep 30
        fi

  run-health-checks:
    name: Run Health Checks
    runs-on: ubuntu-latest
    needs: deploy-services

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Health check services
      run: |
        SERVICES="eureka-server api-gateway authentication-service customer-service consumption-service elering-adapter energy-company-client"
        
        for service in $SERVICES; do
          echo "Checking health of $service..."
          
          # Get the load balancer URL for the service
          # This is a simplified example - in practice you'd get the actual ALB endpoint
          echo "Health check for $service would happen here"
          
          # You could make actual HTTP requests to health endpoints
          # curl -f http://your-alb-endpoint/actuator/health || exit 1
        done
        
        echo "All services are healthy!"

  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [deploy-services, run-health-checks]
    if: success()

    steps:
    - name: Send success notification
      run: |
        echo "🎉 Production deployment successful!"
        echo "Commit: ${{ github.sha }}"
        echo "All services have been deployed and are healthy."
        
        # Here you could send notifications to Slack, email, etc.
        # Example: Send to Slack webhook
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"🚀 Energy Company production deployment successful!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-services, run-health-checks]
    if: failure()

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Rollback services
      run: |
        echo "🚨 Deployment failed - initiating rollback..."
        
        SERVICES="energy-company-client api-gateway authentication-service elering-adapter consumption-service customer-service"
        
        for service in $SERVICES; do
          ECS_SERVICE="$service-prod"
          
          echo "Rolling back $service..."
          
          # Get the previous task definition revision
          PREVIOUS_REVISION=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE \
            --query 'services[0].deployments[?status==`PRIMARY`].taskDefinition' --output text | \
            sed 's/.*://' | awk '{print $1-1}')
          
          if [ "$PREVIOUS_REVISION" -gt 0 ]; then
            PREVIOUS_TASK_DEF="${service}-prod:${PREVIOUS_REVISION}"
            
            aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE \
              --task-definition $PREVIOUS_TASK_DEF
              
            echo "Rolled back $service to revision $PREVIOUS_REVISION"
          fi
        done
        
        echo "Rollback completed"
        
        # Send failure notification
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"❌ Energy Company production deployment failed and was rolled back"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}