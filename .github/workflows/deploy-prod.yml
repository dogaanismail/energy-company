name: Deploy to Production

on:
  push:
    branches: [ main, master ]

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER: energy-company-prod
  JAVA_VERSION: '21'
  NODE_VERSION: '23'

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      changed-services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
      deployment-order: ${{ steps.changes.outputs.deployment-order }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changed services
      id: changes
      run: |
        # Get the previous commit
        PREV_SHA=$(git rev-parse HEAD~1)
        
        # Get list of changed files
        CHANGED_FILES=$(git diff --name-only $PREV_SHA...HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Initialize services array
        SERVICES=()
        
        # Check each service for changes
        if echo "$CHANGED_FILES" | grep -q "^api-gateway/"; then
          SERVICES+=("api-gateway")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^authentication-service/"; then
          SERVICES+=("authentication-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service/"; then
          SERVICES+=("consumption-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^consumption/consumption-service-db-migration/"; then
          SERVICES+=("consumption-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service/"; then
          SERVICES+=("customer-service")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^customer/customer-service-db-migration/"; then
          SERVICES+=("customer-service-db-migration")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^elering-adapter/"; then
          SERVICES+=("elering-adapter")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^eureka-server/"; then
          SERVICES+=("eureka-server")
        fi
        
        if echo "$CHANGED_FILES" | grep -q "^energy-company-client/"; then
          SERVICES+=("energy-company-client")
        fi
        
        # Check for infrastructure changes
        if echo "$CHANGED_FILES" | grep -q "^\.aws/\|^\.github/workflows/\|^docker-compose\|^build\.gradle$\|^settings\.gradle$"; then
          echo "Infrastructure or global changes detected - deploying all services"
          SERVICES=("eureka-server" "customer-service-db-migration" "consumption-service-db-migration" "customer-service" "consumption-service" "elering-adapter" "authentication-service" "api-gateway" "energy-company-client")
        fi
        
        # Create deployment order based on priorities
        PRIORITY_1=()  # eureka-server
        PRIORITY_2=()  # db migrations
        PRIORITY_3=()  # core services
        PRIORITY_4=()  # authentication
        PRIORITY_5=()  # api-gateway
        PRIORITY_6=()  # frontend
        
        for service in "${SERVICES[@]}"; do
          case $service in
            "eureka-server") PRIORITY_1+=("$service") ;;
            *"db-migration") PRIORITY_2+=("$service") ;;
            "customer-service"|"consumption-service"|"elering-adapter") PRIORITY_3+=("$service") ;;
            "authentication-service") PRIORITY_4+=("$service") ;;
            "api-gateway") PRIORITY_5+=("$service") ;;
            "energy-company-client") PRIORITY_6+=("$service") ;;
          esac
        done
        
        # Combine in deployment order
        ORDERED_SERVICES=(${PRIORITY_1[@]} ${PRIORITY_2[@]} ${PRIORITY_3[@]} ${PRIORITY_4[@]} ${PRIORITY_5[@]} ${PRIORITY_6[@]})
        
        # Convert to JSON format compatible with GitHub Actions matrix
        if [ ${#SERVICES[@]} -eq 0 ]; then
          echo "services=[]" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
          echo "deployment-order=[]" >> $GITHUB_OUTPUT
          echo "No services have changed"
        else
          # Create properly formatted JSON arrays
          SERVICES_JSON="["
          for i in "${!SERVICES[@]}"; do
            if [ $i -gt 0 ]; then
              SERVICES_JSON+=","
            fi
            SERVICES_JSON+="\"${SERVICES[$i]}\""
          done
          SERVICES_JSON+="]"
          
          ORDERED_JSON="["
          for i in "${!ORDERED_SERVICES[@]}"; do
            if [ $i -gt 0 ]; then
              ORDERED_JSON+=","
            fi
            ORDERED_JSON+="\"${ORDERED_SERVICES[$i]}\""
          done
          ORDERED_JSON+="]"
          
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "deployment-order=$ORDERED_JSON" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "Services to deploy: ${SERVICES[*]}"
          echo "Deployment order: ${ORDERED_SERVICES[*]}"
          echo "Generated services JSON: $SERVICES_JSON"
          echo "Generated order JSON: $ORDERED_JSON"
        fi

  deploy-infrastructure:
    name: Deploy Infrastructure (if changed)
    runs-on: ubuntu-latest
    needs: detect-changes
    if: contains(needs.detect-changes.outputs.changed-services, 'infrastructure') || needs.detect-changes.outputs.has-changes == 'false'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy infrastructure if needed
      run: |
        echo "Infrastructure deployment would happen here if .aws/ files changed"
        # This could deploy your CloudFormation stack if infrastructure files changed

  build-and-deploy:
    name: Build and Deploy Changed Services
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infrastructure]
    if: needs.detect-changes.outputs.has-changes == 'true'

    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.deployment-order) }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set service path
      id: service-path
      run: |
        if [ "${{ matrix.service.path }}" != "" ]; then
          echo "path=${{ matrix.service.path }}" >> $GITHUB_OUTPUT
        else
          echo "path=${{ matrix.service.name }}" >> $GITHUB_OUTPUT
        fi

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      if: matrix.service.name != 'energy-company-client'
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Set up Node.js ${{ env.NODE_VERSION }}
      if: matrix.service.name == 'energy-company-client'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: energy-company-client/package-lock.json

    - name: Cache Gradle packages
      if: matrix.service.name != 'energy-company-client'
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Build backend service
      if: matrix.service.name != 'energy-company-client'
      run: |
        chmod +x ./gradlew
        ./gradlew clean build -x test --no-daemon

    - name: Build frontend
      if: matrix.service.name == 'energy-company-client'
      working-directory: ./energy-company-client
      run: |
        npm ci
        npm run build

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REPOSITORY: energy-company-${{ matrix.service.name }}-prod
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create ECR repository if it doesn't exist
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
        # Build and push Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ${{ steps.service-path.outputs.path }}
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy-services:
    name: Deploy Services by Priority
    runs-on: ubuntu-latest
    needs: build-and-deploy

    strategy:
      matrix:
        priority: [1, 2, 3, 4, 5, 6]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy services with priority ${{ matrix.priority }}
      env:
        IMAGE_TAG: ${{ github.sha }}
        PRIORITY: ${{ matrix.priority }}
      run: |
        # Define services by priority
        case $PRIORITY in
          1) SERVICES="eureka-server" ;;
          2) SERVICES="customer-service-db-migration consumption-service-db-migration" ;;
          3) SERVICES="customer-service consumption-service elering-adapter" ;;
          4) SERVICES="authentication-service" ;;
          5) SERVICES="api-gateway" ;;
          6) SERVICES="energy-company-client" ;;
        esac
        
        for service in $SERVICES; do
          echo "Deploying $service..."
          
          ECR_REPOSITORY="energy-company-$service-prod"
          ECS_SERVICE="$service-prod"
          ECS_TASK_DEFINITION="$service-prod"
          
          # Check if service exists
          if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION 2>/dev/null | grep -q "ACTIVE"; then
            echo "Updating existing service: $service"
            
            # Download current task definition
            aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION \
              --query taskDefinition > task-definition.json
            
            # Update the image in task definition
            python3 - << EOF
        import json
        
        with open('task-definition.json', 'r') as f:
            task_def = json.load(f)
        
        # Remove fields that shouldn't be in the updated task definition
        for key in ['taskDefinitionArn', 'revision', 'status', 'requiresAttributes', 'placementConstraints', 'compatibilities', 'registeredAt', 'registeredBy']:
            task_def.pop(key, None)
        
        # Update the image
        for container in task_def['containerDefinitions']:
            if container['name'] == '$service':
                container['image'] = '$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG'
        
        with open('task-definition-updated.json', 'w') as f:
            json.dump(task_def, f, indent=2)
        EOF
            
            # Register new task definition
            aws ecs register-task-definition --cli-input-json file://task-definition-updated.json
            
            # Update the service
            aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE \
              --task-definition $ECS_TASK_DEFINITION
              
            # Wait for deployment to complete
            aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE
            
          else
            echo "Service $service does not exist yet - would need to be created with proper task definition"
          fi
        done
        
        # Wait between priority levels
        if [ "$PRIORITY" -lt 6 ]; then
          echo "Waiting 30 seconds before next priority level..."
          sleep 30
        fi

  run-health-checks:
    name: Run Health Checks
    runs-on: ubuntu-latest
    needs: deploy-services

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Health check services
      run: |
        SERVICES="eureka-server api-gateway authentication-service customer-service consumption-service elering-adapter energy-company-client"
        
        for service in $SERVICES; do
          echo "Checking health of $service..."
          
          # Get the load balancer URL for the service
          # This is a simplified example - in practice you'd get the actual ALB endpoint
          echo "Health check for $service would happen here"
          
          # You could make actual HTTP requests to health endpoints
          # curl -f http://your-alb-endpoint/actuator/health || exit 1
        done
        
        echo "All services are healthy!"

  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-deploy]
    if: success() && needs.detect-changes.outputs.has-changes == 'true'

    steps:
    - name: Send success notification
      run: |
        SERVICES="${{ join(fromJson(needs.detect-changes.outputs.changed-services), ', ') }}"
        echo "ðŸŽ‰ Production deployment successful!"
        echo "Services deployed: $SERVICES"
        echo "Commit: ${{ github.sha }}"
        
        # Send to Slack, email, etc.
        # curl -X POST -H 'Content-type: application/json' \
        #   --data "{\"text\":\"ðŸš€ Energy Company production deployment successful!\nServices: $SERVICES\"}" \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-services, run-health-checks]
    if: failure()

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Rollback services
      run: |
        echo "ðŸš¨ Deployment failed - initiating rollback..."
        
        SERVICES="energy-company-client api-gateway authentication-service elering-adapter consumption-service customer-service"
        
        for service in $SERVICES; do
          ECS_SERVICE="$service-prod"
          
          echo "Rolling back $service..."
          
          # Get the previous task definition revision
          PREVIOUS_REVISION=$(aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE \
            --query 'services[0].deployments[?status==`PRIMARY`].taskDefinition' --output text | \
            sed 's/.*://' | awk '{print $1-1}')
          
          if [ "$PREVIOUS_REVISION" -gt 0 ]; then
            PREVIOUS_TASK_DEF="${service}-prod:${PREVIOUS_REVISION}"
            
            aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE \
              --task-definition $PREVIOUS_TASK_DEF
              
            echo "Rolled back $service to revision $PREVIOUS_REVISION"
          fi
        done
        
        echo "Rollback completed"
        
        # Send failure notification
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"âŒ Energy Company production deployment failed and was rolled back"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}